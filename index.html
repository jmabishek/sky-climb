<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>‚òÅ Infinite Sky Climb</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: radial-gradient(circle at top, #0f172a, #020617);
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #e5e7eb;
    }
    .wrapper {
      width: 100%;
      max-width: 900px;
      padding: 12px;
    }
    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      gap: 8px;
      flex-wrap: wrap;
    }
    .title {
      font-size: 1.3rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .stats {
      display: flex;
      gap: 12px;
      font-size: 0.9rem;
      flex-wrap: wrap;
    }
    .controls {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }
    button {
      border: none;
      border-radius: 999px;
      padding: 5px 12px;
      font-size: 0.8rem;
      cursor: pointer;
      background: #020617;
      color: #e5e7eb;
      border: 1px solid #1f2937;
      transition: background 0.15s ease, transform 0.1s ease, box-shadow 0.15s ease;
    }
    button:hover { background: #0b1120; box-shadow: 0 4px 12px rgba(15,23,42,0.6); }
    button:active { transform: translateY(1px); box-shadow: none; }

    .canvas-shell {
      background: #020617;
      border-radius: 18px;
      overflow: hidden;
      border: 1px solid #1f2937;
      box-shadow: 0 18px 40px rgba(15,23,42,0.9);
      position: relative;
    }
    canvas {
      display: block;
      width: 100%;
      height: auto;
      touch-action: none;
    }
    .overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at top, rgba(15,23,42,0.9), rgba(15,23,42,0.98));
      color: #e5e7eb;
      flex-direction: column;
      gap: 10px;
      text-align: center;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s ease;
    }
    .overlay.visible { opacity: 1; pointer-events: auto; }
    .overlay h1 { font-size: 1.6rem; margin-bottom: 4px; }
    .overlay p { font-size: 0.9rem; opacity: 0.85; }
    .overlay button { margin-top: 6px; }

    .mobile-buttons {
      display: flex;
      justify-content: center;
      gap: 14px;
      margin-top: 8px;
    }
    .mobile-btn {
      width: 72px;
      height: 40px;
      border-radius: 999px;
      font-size: 1.1rem;
    }
    .footer {
      margin-top: 6px;
      font-size: 0.7rem;
      text-align: right;
      opacity: 0.7;
    }

    @media (max-width: 600px) {
      .title { font-size: 1.1rem; }
      .stats { font-size: 0.8rem; }
      button { font-size: 0.75rem; padding: 4px 10px; }
      .mobile-btn { width: 64px; height: 38px; }
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <div class="top-bar">
      <div class="title">‚òÅ Infinite Sky Climb</div>
      <div class="stats">
        <div>Height: <span id="score">0</span> m</div>
        <div>Best: <span id="bestScore">0</span> m</div>
        <div>Coins: <span id="coins">0</span></div>
        <div>Lives: <span id="lives">3</span></div>
      </div>
      <div class="controls">
        <button id="musicBtn">üîà Music</button>
        <button id="shopBtn">üõí Shop</button>
        <button id="pauseBtn">‚è∏ Pause</button>
        <button id="resumeBtn">‚ñ∂ Resume</button>
      </div>
    </div>
    <div class="canvas-shell">
      <canvas id="gameCanvas"></canvas>
      <div id="overlay" class="overlay">
        <h1>Game Over</h1>
        <p id="gameOverText">Tap Restart to climb again!</p>
        <button id="restartBtn">üîÅ Restart</button>
      </div>
    </div>
    <div class="mobile-buttons">
      <button id="leftBtn" class="mobile-btn">‚üµ</button>
      <button id="rightBtn" class="mobile-btn">‚ü∂</button>
    </div>
    <div class="footer">
      <span id="dailyChallenge"></span>
    </div>
  </div>

  <!-- background music (royalty-free) -->
  <audio id="bgm" loop src="https://cdn.pixabay.com/audio/2022/03/15/audio_3f52b3c172.mp3"></audio>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const overlay = document.getElementById("overlay");
    const scoreEl = document.getElementById("score");
    const bestScoreEl = document.getElementById("bestScore");
    const livesEl = document.getElementById("lives");
    const coinsEl = document.getElementById("coins");
    const bgm = document.getElementById("bgm");
    const dailyChallengeEl = document.getElementById("dailyChallenge");
    const gameOverTextEl = document.getElementById("gameOverText");

    function resizeCanvas() {
      const width = document.querySelector(".canvas-shell").clientWidth;
      const height = Math.max(260, Math.min(520, width * 0.65));
      canvas.width = width;
      canvas.height = height;
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    // === DAILY CHALLENGE (simple) ===
    (function setDailyChallenge() {
      const today = new Date();
      const seed = today.getFullYear() * 10000 + (today.getMonth()+1)*100 + today.getDate();
      const target = 600 + (seed % 1200); // random-ish between 600 and 1800
      dailyChallengeEl.textContent = `üéØ Daily Challenge: Reach ${target} m today!`;
    })();

    // === GAME STATE ===
    let player, platforms, enemies, powerUps, particles, coins, boss;
    let score = 0;
    let bestScore = parseInt(localStorage.getItem("skyClimbBest") || "0", 10);
    bestScoreEl.textContent = bestScore;
    let lives = 3;
    let coinCount = 0;
    coinsEl.textContent = coinCount;
    let paused = false;
    let gameOver = false;
    let started = false;

    const gravityBase = 0.18;
    let windForce = 0;         // for weather
    let windTimer = 0;
    let rainDrops = [];

    function resetGame() {
      const startX = canvas.width / 2;
      const startY = canvas.height - 70;
      player = {
        x: startX,
        y: startY,
        radius: 18,
        dx: 0,
        dy: -5,
        baseColor: "#4ade80",
        color: "#4ade80",
        shield: false,
        slowMotion: false,
        jetBoostTime: 0,
        trail: []
      };
      platforms = [];
      enemies = [];
      powerUps = [];
      particles = [];
      coins = [];
      boss = null;
      score = 0;
      lives = 3;
      paused = false;
      gameOver = false;
      overlay.classList.remove("visible");
      livesEl.textContent = lives;
      scoreEl.textContent = score;
      coinCount = coinCount || 0;
      coinsEl.textContent = coinCount;
      initPlatforms();
      spawnInitialEnemies();
      spawnInitialPowerUps();
      spawnInitialCoins();
    }

    function initPlatforms() {
      const gap = 110;
      for (let i = 0; i < 12; i++) {
        const y = canvas.height - i * gap;
        platforms.push(createPlatform(y));
      }
    }

    function createPlatform(y) {
      return {
        x: Math.random() * (canvas.width - 120),
        y,
        width: 120,
        height: 14,
        color: "#38bdf8",
        durability: Math.random() < 0.3 ? 1 : 3, // breakable vs strong
      };
    }

    function spawnInitialEnemies() {
      for (let i = 0; i < 3; i++) {
        enemies.push(createEnemy(canvas.height - i * 200));
      }
    }

    function createEnemy(y) {
      const dir = Math.random() < 0.5 ? 1 : -1;
      return {
        x: dir === 1 ? -40 : canvas.width + 40,
        y,
        width: 40,
        height: 26,
        dx: (1.5 + Math.random() * 1.5) * dir,
        color: "#f97373",
      };
    }

    function spawnInitialPowerUps() {
      for (let i = 0; i < 2; i++) {
        powerUps.push(createPowerUp(canvas.height - 300 - i * 200));
      }
    }

    function createPowerUp(y) {
      const types = ["jet", "shield", "slow"];
      const type = types[Math.floor(Math.random() * types.length)];
      return {
        x: Math.random() * (canvas.width - 24) + 12,
        y,
        radius: 10,
        type,
      };
    }

    function spawnInitialCoins() {
      for (let i = 0; i < 4; i++) {
        coins.push(createCoin(canvas.height - 200 - i * 180));
      }
    }

    function createCoin(y) {
      return {
        x: Math.random() * (canvas.width - 20) + 10,
        y,
        radius: 7
      };
    }

    // Boss
    function maybeSpawnBoss() {
      if (boss) return;
      if (score >= 800 && score < 900) {
        boss = {
          x: canvas.width / 2 - 50,
          y: canvas.height * 0.25,
          width: 100,
          height: 40,
          dx: 2.5,
          hp: 5,
          active: true
        };
      }
    }

    // === INPUT ===
    let left = false, right = false;

    document.addEventListener("keydown", (e) => {
      if (e.key === "ArrowLeft") left = true;
      if (e.key === "ArrowRight") right = true;
      if (!started && (e.key === "ArrowLeft" || e.key === "ArrowRight")) {
        started = true;
        tryPlayMusic();
      }
    });
    document.addEventListener("keyup", (e) => {
      if (e.key === "ArrowLeft") left = false;
      if (e.key === "ArrowRight") right = false;
    });

    // Mobile buttons
    const leftBtn = document.getElementById("leftBtn");
    const rightBtn = document.getElementById("rightBtn");

    function bindTouch(btn, dir) {
      btn.addEventListener("touchstart", (e) => {
        e.preventDefault();
        if (dir === "left") left = true;
        if (dir === "right") right = true;
        if (!started) {
          started = true;
          tryPlayMusic();
        }
      });
      btn.addEventListener("touchend", (e) => {
        e.preventDefault();
        if (dir === "left") left = false;
        if (dir === "right") right = false;
      });
    }
    bindTouch(leftBtn, "left");
    bindTouch(rightBtn, "right");

    canvas.addEventListener("touchstart", (e) => {
      if (!started) {
        started = true;
        tryPlayMusic();
      }
    });

    // === MUSIC & CONTROLS ===
    const musicBtn = document.getElementById("musicBtn");
    let musicOn = false;
    function tryPlayMusic() {
      if (!musicOn) {
        bgm.volume = 0.35;
        bgm.play().catch(() => {});
        musicOn = true;
        musicBtn.textContent = "üîä Music";
      }
    }
    musicBtn.addEventListener("click", () => {
      if (!musicOn) {
        tryPlayMusic();
      } else {
        bgm.pause();
        musicOn = false;
        musicBtn.textContent = "üîà Music";
      }
    });

    document.getElementById("pauseBtn").onclick = () => (paused = true);
    document.getElementById("resumeBtn").onclick = () => {
      if (!gameOver) paused = false;
    };
    document.getElementById("restartBtn").onclick = () => {
      resetGame();
    };

    // Shop: simple skin unlock
    const shopBtn = document.getElementById("shopBtn");
    shopBtn.addEventListener("click", () => {
      if (coinCount >= 20) {
        coinCount -= 20;
        coinsEl.textContent = coinCount;
        // toggle skin
        if (player.baseColor === "#4ade80") {
          player.baseColor = "#f97316"; // orange
        } else {
          player.baseColor = "#4ade80";
        }
        player.color = player.baseColor;
        alert("Skin changed! (cost 20 coins)");
      } else {
        alert("Need at least 20 coins to change skin.");
      }
    });

    // === PARTICLES ===
    function spawnParticles(x, y, color, count = 10) {
      for (let i = 0; i < count; i++) {
        particles.push({
          x,
          y,
          dx: (Math.random() - 0.5) * 4,
          dy: (Math.random() - 0.5) * 4,
          life: 30 + Math.random() * 20,
          color,
        });
      }
    }

    // === COLLISION HELPERS ===
    function rectIntersect(ax, ay, aw, ah, bx, by, bw, bh) {
      return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
    }

    // === WEATHER: WIND + RAIN ===
    function updateWeather() {
      windTimer--;
      if (windTimer <= 0) {
        // change wind every few seconds
        windTimer = 240 + Math.floor(Math.random() * 240);
        windForce = (Math.random() - 0.5) * 0.4; // -0.2 to 0.2
      }

      // Rain only in higher worlds (Space/Galaxy style)
      const world = getWorld();
      if (world >= 1) {
        if (rainDrops.length < 80) {
          for (let i = 0; i < 3; i++) {
            rainDrops.push({
              x: Math.random() * canvas.width,
              y: -10,
              dy: 4 + Math.random() * 3
            });
          }
        }
        rainDrops.forEach((r, i) => {
          r.y += r.dy;
          if (r.y > canvas.height + 10) {
            rainDrops.splice(i, 1);
          }
        });
      } else {
        rainDrops = [];
      }
    }

    // === WORLD THEMES ===
    function getWorld() {
      if (score < 800) return 0;        // Cloud world
      if (score < 1800) return 1;       // Space
      return 2;                         // Galaxy
    }

    function getWorldGradient() {
      const world = getWorld();
      if (world === 0) {
        return ["#38bdf8", "#1d4ed8"]; // blue sky
      } else if (world === 1) {
        return ["#0f172a", "#4b21a2"]; // deep space
      } else {
        return ["#020617", "#9333ea"]; // galaxy purple
      }
    }

    // === MAIN UPDATE ===
    function update() {
      if (paused || gameOver) return;

      updateWeather();

      // Horizontal input (with a bit of wind)
      if (left) player.dx = -4.2 + windForce * 4;
      else if (right) player.dx = 4.2 + windForce * 4;
      else player.dx = windForce * 4 * 0.5;

      player.x += player.dx;
      if (player.x < -player.radius) player.x = canvas.width + player.radius;
      if (player.x > canvas.width + player.radius) player.x = -player.radius;

      // Gravity & power-ups
      let gravity = gravityBase;
      if (player.slowMotion) gravity *= 0.4;
      if (player.jetBoostTime > 0) {
        player.dy = -6;
        player.jetBoostTime--;
      } else {
        player.dy += gravity;
      }

      player.y += player.dy;

      // trail
      player.trail.push({ x: player.x, y: player.y, life: 20 });
      if (player.trail.length > 40) player.trail.shift();

      // Platform collisions (only when falling)
      if (player.dy > 0) {
        platforms.forEach((p) => {
          if (
            player.y + player.radius >= p.y &&
            player.y + player.radius <= p.y + p.height + 6 &&
            player.x >= p.x &&
            player.x <= p.x + p.width
          ) {
            player.dy = -7.5;
            spawnParticles(player.x, p.y, "#38bdf8", 12);
            p.durability--;
            if (p.durability <= 0) {
              spawnParticles(p.x + p.width / 2, p.y, "#60a5fa", 18);
              p.y = canvas.height + 999; // move out; will be recycled
            }
          }
        });
      }

      // Enemies movement & collisions
      enemies.forEach((e) => {
        e.x += e.dx;
        if (e.dx > 0 && e.x > canvas.width + 60) {
          e.x = -60;
        } else if (e.dx < 0 && e.x < -60) {
          e.x = canvas.width + 60;
        }

        if (
          rectIntersect(
            player.x - player.radius,
            player.y - player.radius,
            player.radius * 2,
            player.radius * 2,
            e.x,
            e.y,
            e.width,
            e.height
          )
        ) {
          if (player.shield) {
            player.shield = false;
            spawnParticles(player.x, player.y, "#facc15", 20);
          } else {
            handleDamage();
          }
        }
      });

      // Boss logic
      maybeSpawnBoss();
      if (boss && boss.active) {
        boss.x += boss.dx;
        if (boss.x < 0 || boss.x + boss.width > canvas.width) {
          boss.dx *= -1;
        }

        // Boss collision
        if (
          rectIntersect(
            player.x - player.radius,
            player.y - player.radius,
            player.radius * 2,
            player.radius * 2,
            boss.x,
            boss.y,
            boss.width,
            boss.height
          )
        ) {
          if (player.shield) {
            player.shield = false;
            spawnParticles(player.x, player.y, "#facc15", 25);
          } else {
            handleDamage();
          }
        }

        // Hitting boss from top gives damage
        if (
          player.dy > 0 &&
          player.y + player.radius >= boss.y &&
          player.y + player.radius <= boss.y + boss.height &&
          player.x >= boss.x &&
          player.x <= boss.x + boss.width
        ) {
          boss.hp--;
          player.dy = -8;
          spawnParticles(player.x, boss.y, "#fb7185", 25);
          if (boss.hp <= 0) {
            boss.active = false;
            spawnParticles(boss.x + boss.width / 2, boss.y + boss.height / 2, "#f97316", 40);
            // reward
            coinCount += 15;
            coinsEl.textContent = coinCount;
          }
        }
      }

      // Power-up collisions
      powerUps.forEach((pu, idx) => {
        const dist = Math.hypot(player.x - pu.x, player.y - pu.y);
        if (dist < player.radius + pu.radius) {
          applyPowerUp(pu.type);
          spawnParticles(pu.x, pu.y, "#f97316", 20);
          powerUps.splice(idx, 1);
        }
      });

      // Coin collisions
      coins.forEach((c, idx) => {
        const dist = Math.hypot(player.x - c.x, player.y - c.y);
        if (dist < player.radius + c.radius) {
          coinCount += 1;
          coinsEl.textContent = coinCount;
          spawnParticles(c.x, c.y, "#facc15", 15);
          coins.splice(idx, 1);
        }
      });

      // Infinite upward scroll
      if (player.y < canvas.height * 0.4) {
        const shift = canvas.height * 0.4 - player.y;
        player.y = canvas.height * 0.4;
        score += Math.floor(shift * 0.1);
        scoreEl.textContent = score;

        platforms.forEach((p, i) => {
          p.y += shift;
          if (p.y > canvas.height + 40) {
            platforms[i] = createPlatform(p.y - canvas.height - 120);
          }
        });

        enemies.forEach((e, i) => {
          e.y += shift;
          if (e.y > canvas.height + 60) {
            enemies[i] = createEnemy(e.y - canvas.height - 200);
          }
        });

        powerUps.forEach((pu, i) => {
          pu.y += shift;
          if (pu.y > canvas.height + 40) {
            if (Math.random() < 0.4) {
              powerUps[i] = createPowerUp(pu.y - canvas.height - 220);
            }
          }
        });

        coins.forEach((c, i) => {
          c.y += shift;
          if (c.y > canvas.height + 40) {
            if (Math.random() < 0.5) {
              coins[i] = createCoin(c.y - canvas.height - 180);
            }
          }
        });

        // Difficulty scaling based on score
        const difficultyFactor = 1 + score / 500;
        enemies.forEach((e) => {
          e.dx = Math.sign(e.dx) * (1.5 + Math.random() * 1.5 * difficultyFactor * 0.4);
        });
      }

      // Player falls below screen
      if (player.y - player.radius > canvas.height + 60) {
        handleDamage(true);
      }

      // Update particles
      particles.forEach((pt, i) => {
        pt.x += pt.dx;
        pt.y += pt.dy;
        pt.dy += 0.05;
        pt.life--;
        if (pt.life <= 0) particles.splice(i, 1);
      });

      // Update trail
      player.trail.forEach(t => t.life--);
      player.trail = player.trail.filter(t => t.life > 0);
    }

    function handleDamage(fall = false) {
      if (gameOver) return;
      spawnParticles(player.x, player.y, "#f97373", 25);
      lives--;
      livesEl.textContent = lives;
      if (lives <= 0) {
        endGame(fall);
      } else {
        // reset player position but keep progress
        player.x = canvas.width / 2;
        player.y = canvas.height * 0.3;
        player.dy = -4;
      }
    }

    function applyPowerUp(type) {
      if (type === "shield") {
        player.shield = true;
      } else if (type === "slow") {
        player.slowMotion = true;
        setTimeout(() => {
          player.slowMotion = false;
        }, 4000);
      } else if (type === "jet") {
        player.jetBoostTime = 120; // ~2 seconds
      }
    }

    function endGame(fall = false) {
      gameOver = true;
      paused = true;
      if (score > bestScore) {
        bestScore = score;
        localStorage.setItem("skyClimbBest", bestScore.toString());
        bestScoreEl.textContent = bestScore;
        gameOverTextEl.textContent = "New High Score! üéâ";
      } else {
        gameOverTextEl.textContent = "You fell from the sky ‚òÅ Try again!";
      }
      overlay.classList.add("visible");
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Background gradient depends on world
      const [c1, c2] = getWorldGradient();
      const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
      grad.addColorStop(0, c1);
      grad.addColorStop(1, c2);
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Rain
      ctx.strokeStyle = "rgba(148, 163, 184, 0.6)";
      rainDrops.forEach((r) => {
        ctx.beginPath();
        ctx.moveTo(r.x, r.y);
        ctx.lineTo(r.x, r.y + 8);
        ctx.stroke();
      });

      // Platforms
      platforms.forEach((p) => {
        const alpha = p.durability === 1 ? 0.7 : 1;
        ctx.fillStyle = `rgba(56,189,248,${alpha})`;
        ctx.fillRect(p.x, p.y, p.width, p.height);
      });

      // Enemies
      enemies.forEach((e) => {
        ctx.fillStyle = e.color;
        ctx.fillRect(e.x, e.y, e.width, e.height);
        ctx.fillStyle = "#111827";
        ctx.fillRect(e.x + 8, e.y + 8, 8, 4);
        ctx.fillRect(e.x + 24, e.y + 8, 8, 4);
      });

      // Boss
      if (boss && boss.active) {
        ctx.fillStyle = "#f97373";
        ctx.fillRect(boss.x, boss.y, boss.width, boss.height);
        // HP bar
        ctx.fillStyle = "#111827";
        ctx.fillRect(boss.x, boss.y - 8, boss.width, 5);
        ctx.fillStyle = "#22c55e";
        ctx.fillRect(boss.x, boss.y - 8, (boss.hp / 5) * boss.width, 5);
      }

      // Power-ups
      powerUps.forEach((pu) => {
        let color = "#facc15"; // shield
        if (pu.type === "jet") color = "#22c55e";
        if (pu.type === "slow") color = "#a855f7";
        ctx.beginPath();
        ctx.arc(pu.x, pu.y, pu.radius, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();
      });

      // Coins
      coins.forEach((c) => {
        ctx.beginPath();
        ctx.arc(c.x, c.y, c.radius, 0, Math.PI * 2);
        ctx.fillStyle = "#facc15";
        ctx.fill();
        ctx.strokeStyle = "#eab308";
        ctx.stroke();
      });

      // Trail
      player.trail.forEach(t => {
        ctx.beginPath();
        ctx.arc(t.x, t.y, 4, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(74, 222, 128," + (t.life / 20) + ")";
        ctx.fill();
      });

      // Player
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
      ctx.fillStyle = player.baseColor;
      ctx.shadowColor = player.baseColor;
      ctx.shadowBlur = 12;
      ctx.fill();
      ctx.shadowBlur = 0;

      if (player.shield) {
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.radius + 4, 0, Math.PI * 2);
        ctx.strokeStyle = "#facc15";
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      // Particles
      particles.forEach((pt) => {
        ctx.fillStyle = pt.color;
        ctx.globalAlpha = Math.max(pt.life / 50, 0);
        ctx.fillRect(pt.x, pt.y, 3, 3);
        ctx.globalAlpha = 1;
      });
    }

    function loop() {
      update();
      draw();
      requestAnimationFrame(loop);
    }

    // INIT
    resetGame();
    loop();
  </script>
</body>
</html>
